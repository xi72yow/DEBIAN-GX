#!/usr/bin/env bash
# This script was generated by bashly 0.9.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
dgxa_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa - application to administrate deb-gx live build from debgx root folder\n"
    echo

  else
    printf "dgxa - application to administrate deb-gx live build from debgx root folder\n"
    echo

  fi

  printf "Usage:\n"
  printf "  dgxa COMMAND\n"
  printf "  dgxa [COMMAND] --help | -h\n"
  printf "  dgxa --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  download                 download dracula styles and .deb Packages"
  echo "  installdev               install admin dev dependencies"
  echo "  generatecodeex           gererate VSCode extension install script from current setup"
  echo "  generatechromeex         gererate Chrome extension list from current setup"
  echo "  buildca                  build config-app"
  echo "  generateloginscreen      generates gresource for login screen needs gnome-shell-theme.gresource in lfs and wallpaper in branding"
  echo "  generateplymouthsplash   generates plymouth splash from plymouth.mp4 in branding or used the debgx_plymouth"
  echo "  build                    build debgx"
  echo "  setcalamares             set files for calamaris installer from branding"
  echo "  setlogin                 set login style"
  echo "  setplymouth              set setplymouth animation"
  echo "  setfiles                 set files to /home/.deb-gx"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
dgxa_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa download - download dracula styles and .deb Packages\n"
    echo

  else
    printf "dgxa download - download dracula styles and .deb Packages\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "Usage:\n"
  printf "  dgxa download\n"
  printf "  dgxa download --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_installdev_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa installdev - install admin dev dependencies\n"
    echo

  else
    printf "dgxa installdev - install admin dev dependencies\n"
    echo

  fi

  printf "Alias: id\n"
  echo

  printf "Usage:\n"
  printf "  dgxa installdev\n"
  printf "  dgxa installdev --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_generatecodeex_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa generatecodeex - gererate VSCode extension install script from current setup\n"
    echo

  else
    printf "dgxa generatecodeex - gererate VSCode extension install script from current setup\n"
    echo

  fi

  printf "Alias: gce\n"
  echo

  printf "Usage:\n"
  printf "  dgxa generatecodeex\n"
  printf "  dgxa generatecodeex --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_generatechromeex_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa generatechromeex - gererate Chrome extension list from current setup\n"
    echo

  else
    printf "dgxa generatechromeex - gererate Chrome extension list from current setup\n"
    echo

  fi

  printf "Alias: gche\n"
  echo

  printf "Usage:\n"
  printf "  dgxa generatechromeex\n"
  printf "  dgxa generatechromeex --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_buildca_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa buildca - build config-app\n"
    echo

  else
    printf "dgxa buildca - build config-app\n"
    echo

  fi

  printf "Alias: bca\n"
  echo

  printf "Usage:\n"
  printf "  dgxa buildca\n"
  printf "  dgxa buildca --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_generateloginscreen_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa generateloginscreen - generates gresource for login screen needs gnome-shell-theme.gresource in lfs and wallpaper in branding\n"
    echo

  else
    printf "dgxa generateloginscreen - generates gresource for login screen needs gnome-shell-theme.gresource in lfs and wallpaper in branding\n"
    echo

  fi

  printf "Alias: gls\n"
  echo

  printf "Usage:\n"
  printf "  dgxa generateloginscreen\n"
  printf "  dgxa generateloginscreen --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_generateplymouthsplash_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa generateplymouthsplash - generates plymouth splash from plymouth.mp4 in branding or used the debgx_plymouth\n"
    echo

  else
    printf "dgxa generateplymouthsplash - generates plymouth splash from plymouth.mp4 in branding or used the debgx_plymouth\n"
    echo

  fi

  printf "Alias: gps\n"
  echo

  printf "Usage:\n"
  printf "  dgxa generateplymouthsplash\n"
  printf "  dgxa generateplymouthsplash --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa build - build debgx\n"
    echo

  else
    printf "dgxa build - build debgx\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "Usage:\n"
  printf "  dgxa build\n"
  printf "  dgxa build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_setcalamares_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa setcalamares - set files for calamaris installer from branding\n"
    echo

  else
    printf "dgxa setcalamares - set files for calamaris installer from branding\n"
    echo

  fi

  printf "Alias: sc\n"
  echo

  printf "Usage:\n"
  printf "  dgxa setcalamares\n"
  printf "  dgxa setcalamares --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_setlogin_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa setlogin - set login style\n"
    echo

  else
    printf "dgxa setlogin - set login style\n"
    echo

  fi

  printf "Alias: sl\n"
  echo

  printf "Usage:\n"
  printf "  dgxa setlogin\n"
  printf "  dgxa setlogin --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_setplymouth_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa setplymouth - set setplymouth animation\n"
    echo

  else
    printf "dgxa setplymouth - set setplymouth animation\n"
    echo

  fi

  printf "Alias: sp\n"
  echo

  printf "Usage:\n"
  printf "  dgxa setplymouth\n"
  printf "  dgxa setplymouth --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
dgxa_setfiles_usage() {
  if [[ -n $long_usage ]]; then
    printf "dgxa setfiles - set files to /home/.deb-gx\n"
    echo

  else
    printf "dgxa setfiles - set files to /home/.deb-gx\n"
    echo

  fi

  printf "Alias: sf\n"
  echo

  printf "Usage:\n"
  printf "  dgxa setfiles\n"
  printf "  dgxa setfiles --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/check_current_folder_function.sh
check_current_folder_funktion() {
    result=${PWD##*/}
    if [ $result == "DEBIAN-GX" ]; then
        echo "Right folder."
    else
        log "Wrong folder. Please change to 'DEB-GX' folder."
        exit
    fi
}

# src/lib/check_root_function.sh
check_root() {
    if [ ! $(id -u) -eq 0 ]; then
        log "Please run as root"
        exit
    fi
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/get_URL_from_latest_release_for_deb_function.sh
get_URL_from_latest_release_for_deb() {
    local resultURLs=$(curl "https://api.github.com/repos/$1/releases" | # Get release from GitHub api
        jq '[.[].assets] | .[0]')
    urls=()
    for variable in $resultURLs; do
        if [[ $variable == *".deb"* ]]; then
            if [[ $variable == *"https:"* ]]; then # Get download URL
                urlSize="$((${#variable} - 1))"
                url=$(echo "$variable" | cut -c2-$urlSize) # Delete the ""
                urls+=("$url")
            fi
        fi
    done

    #contains all .deb releases
    urlsLen=${#urls[@]}
    #no deb releases found
    if ((${urlsLen} < 1)); then
        exit
    fi
    #only one deb release found
    if ((${urlsLen} == 1)); then
        echo "${urls[0]}"
    fi
    #more than one deb release found
    if ((${urlsLen} > 1)); then
        for i in "${urls[@]}"; do
            #check architecture
            if [[ $i == *"amd64"* ]]; then
                echo "$i"
            fi
        done
    fi

}

# src/lib/log_function.sh
exec 3>&1

log() {
    echo "$(red Stop:) $1" 1>&3
}

# src/lib/repack_deb.sh
#repack the .deb file
#ar x Prepros-7.7.0.deb
#zstd -d < control.tar.zst | xz > control.tar.xz
#zstd -d < data.tar.zst | xz > data.tar.xz
#ar -m -c -a sdsd dolibarr_15.0.2-4_all_repacked.deb debian-binary control.tar.xz data.tar.xz
#rm debian-binary control.tar.xz data.tar.xz control.tar.zst data.tar.zst

#TODO: find control file and place in DEBIAN/control
#TODO: remove curious . folder from data.tar.xz

dpkg-deb --info Prepros-7.7.0.deb
if [ $? -eq 0 ]; then
    echo OK
else
    echo FAIL
    #mkdir -p package
    #ar x Prepros-7.7.0.deb --output package
    #for i in package/*.zst; do
    #    zstd -d <$i | xz >"${i%.*}.xz"
    #    rm $i
    #    echo $i
    #done
    #packFiles=""
    #for entry in "package"/*; do
        packFiles="${packFiles} ${entry}"
    #    echo "$entry"
    #done
    #echo $packFiles
    dpkg-deb --build --root-owner-group package
    #ar -m -c -a sdsd package.deb $packFiles
    dpkg-name package.deb
fi

# src/lib/sample_function.sh
sample_function() {
  echo "it works"
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  if [ -d "$1" ]; then
    return 0
  else
    echo "Warning: '$1' NOT found."
    return 1
  fi
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  if [ -f "$1" ]; then
    return 0
  else
    return 1
  fi
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# src/lib/whereis_function.sh
whereis() {
    find . -name "$1*"
}

# :command.command_functions
# :command.function
dgxa_download_command() {
  # src/download_command.sh
  echo "# this file is located in 'src/download_command.sh'"
  echo "# code for 'cli download' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  #build/config/includes.chroot_after_packages/etc/skel/ represents home directory of the user
  home_dir="build/config/includes.chroot_after_packages/etc/skel/"
  ext_dir="build/config/includes.chroot_after_packages/usr/share/gnome-shell/extensions/"
  styles_dir="build/config/includes.chroot_after_packages/usr/share/"
  packages_dir="build/config/packages.chroot/"

  #theming
  #download branding files to branding directory
  if validate_dir_exists "./branding/"; then
      echo "branding files already exists. Skipping..."
  else
      echo "Downloading branding files..."
      curl -o branding.zip "https://xi72yow.de/DEBIAN-GX/branding.zip"
      unzip branding.zip
  fi

  #wallpaper
  if validate_file_exists "${styles_dir}backgrounds/debgx/Wallpaper.png"; then
      echo "Wallpaper.png found."
      echo "skip this step"
  else
      if validate_dir_exists "./branding/"; then
          mkdir -p "${styles_dir}backgrounds/debgx"
          cp ./branding/Wallpaper.png "${styles_dir}backgrounds/debgx/Wallpaper.png"
          echo "Wallpaper.png copied."
      else
          echo "$(red ERROR:) ./branding not found. "
          exit
      fi
  fi

  # dracula theme gtk and icons

  if validate_dir_exists "${styles_dir}icons/"; then
      echo "icons folder found."
      echo "skip this step"
  else
      mkdir -p "${styles_dir}icons"
      curl --location --output "${styles_dir}DraculaIcons.zip" --write-out "%{url_effective}\n" "https://github.com/dracula/gtk/files/5214870/Dracula.zip"
      unzip "${styles_dir}DraculaIcons.zip" -d "${styles_dir}icons"
      rm -rf "${styles_dir}DraculaIcons.zip"
  fi

  if validate_dir_exists "${styles_dir}themes/"; then
      echo "themes folder found."
      echo "skip this step"
  else
      mkdir -p "${styles_dir}themes"
      curl --location --output "${styles_dir}Dracula.zip" --write-out "%{url_effective}\n" "https://github.com/dracula/gtk/archive/master.zip"
      unzip "${styles_dir}Dracula.zip" -d "${styles_dir}themes"
      mv "${styles_dir}themes/gtk-master" "${styles_dir}themes/Dracula"
      rm -rf "${styles_dir}Dracula.zip"
  fi

  #gedit theme
  if validate_file_exists "${home_dir}.local/share/gedit/styles/dracula.xml"; then
      echo "gedit theme folder found."
      echo "skip this step"
  else
      mkdir -p "${home_dir}.local/share/gedit/styles/"
      curl -o "${home_dir}.local/share/gedit/styles/dracula.xml" https://raw.githubusercontent.com/dracula/gedit/master/dracula.xml
  fi

  #gnome-shell extensions
  if validate_dir_exists "${ext_dir}clipboard-indicator@tudmotu.com/"; then
      echo "gnome-shell extensions clipboard-indicator folder found."
      echo "skip this step"
  else
      #clipboard indicator
      mkdir -p "${ext_dir}"
      git clone https://github.com/Tudmotu/gnome-shell-extension-clipboard-indicator.git "${ext_dir}clipboard-indicator@tudmotu.com"
  fi

  #download packages
  if validate_dir_exists "${packages_dir}"; then
      echo "debgx packages folder found."
      echo "remove this folder and regenerate"
      rm -rf "${packages_dir}"
  fi

  mkdir -p "${packages_dir}"

  #Github Desktop "Not Official" and restyled
  download_URL=$(get_URL_from_latest_release_for_deb "xi72yow/desktop-drac")
  curl --location --output "${packages_dir}Github_Desktop_amd64.deb" --write-out "%{url_effective}\n" $download_URL
  dpkg-name "${packages_dir}Github_Desktop_amd64.deb"

  #Godot with themed config
  download_URL=$(get_URL_from_latest_release_for_deb "xi72yow/godot-deb")
  curl --location --output "${packages_dir}Godot_amd64.deb" --write-out "%{url_effective}\n" $download_URL
  dpkg-name "${packages_dir}Godot_amd64.deb"

  #download gum
  download_URL=$(get_URL_from_latest_release_for_deb "charmbracelet/gum")
  curl --location --output "${packages_dir}gum_amd64.deb" --write-out "%{url_effective}\n" $download_URL
  dpkg-name "${packages_dir}gum_amd64.deb"

  #popsicle-gtk "Not Official"
  download_URL=$(get_URL_from_latest_release_for_deb "xi72yow/popsicle-deb")
  curl --location --output "${packages_dir}popsicle_amd64.deb" --write-out "%{url_effective}\n" $download_URL
  dpkg-name "${packages_dir}popsicle_amd64.deb"

  #eddy "Not Official"
  download_URL=$(get_URL_from_latest_release_for_deb "xi72yow/eddy-deb")
  curl --location --output "${packages_dir}eddy_amd64.deb" --write-out "%{url_effective}\n" $download_URL
  dpkg-name "${packages_dir}eddy_amd64.deb"

  #Chrome
  curl https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb --output "${packages_dir}Chrome_amd64.deb"
  dpkg-name "${packages_dir}Chrome_amd64.deb"

  #VS Code
  curl --location --output "${packages_dir}VS_Code_amd64.deb" --write-out "%{url_effective}\n" "https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-x64"
  dpkg-name "${packages_dir}VS_Code_amd64.deb"

  #Discord
  curl --location --output "${packages_dir}Discord_amd64.deb" --write-out "%{url_effective}\n" "https://discordapp.com/api/download?platform=linux&format=deb"
  dpkg-name "${packages_dir}Discord_amd64.deb"

  #Lightworks
  curl https://cdn.lwks.com/releases/2022.1.1/lightworks_2022.1.1_r132926.deb --output "${packages_dir}Lightworks_amd64.deb"
  dpkg-name "${packages_dir}Lightworks_amd64.deb"

  #Prepros is using now zst compression, is not supported by dpkg yet, need to repack it (to do)
  #curl --location --output "${packages_dir}Prepros_amd64.deb" --write-out "%{url_effective}\n" "https://prepros.io/downloads/stable/linux"
  #dpkg-name "${packages_dir}Prepros_amd64.deb"

  #ProtonVPN
  curl https://repo.protonvpn.com/debian/dists/stable/main/binary-all/protonvpn-stable-release_1.0.3_all.deb --output "${packages_dir}ProtonVPN_amd64.deb"
  dpkg-name "${packages_dir}ProtonVPN_amd64.deb"

  #Flashprint
  curl --location --output "${packages_dir}FlashPrint_amd64.deb" --write-out "%{url_effective}\n" "https://en.fss.flashforge.com/10000/software/073e21bbe6ba5c7defb17dbb69708fd8.deb"
  dpkg-name "${packages_dir}FlashPrint_amd64.deb"

  #Steam
  curl --location --output "${packages_dir}Steam_amd64.deb" --write-out "%{url_effective}\n" "https://repo.steampowered.com/steam/archive/stable/steam_latest.deb"
  dpkg-name "${packages_dir}Steam_amd64.deb"

}

# :command.function
dgxa_installdev_command() {
  # src/installdev_command.sh
  echo "# this file is located in 'src/installdev_command.sh'"
  echo "# code for 'dgxa installdev' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  check_root

  sudo apt update
  sudo apt install dpkg-dev ruby-full live-build rpm curl jq zstd -y
  sudo gem install bashly

}

# :command.function
dgxa_generatecodeex_command() {
  # src/generatecodeex_command.sh
  echo "# this file is located in 'src/generatecodeex_command.sh'"
  echo "# code for 'dgxa generatecodeex' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
  ext=$(code --list-extensions)
  installscript="#!/bin/sh \n"
  extpage=""

  echo -e "# install code extensions\n"
  for ext in $ext; do
      installscript=$installscript"code --install-extension $ext\n"
      extpage=$extpage"https://marketplace.visualstudio.com/items?itemName=$ext\n"
  done

  mkdir -p build/config/includes.chroot_after_packages/etc/skel/.deb-gx/
  mkdir -p config-app/src/data/lists/

  echo -e $installscript >build/config/includes.chroot_after_packages/etc/skel/.deb-gx/install-code-extensions.sh
  echo -e $extpage >config-app/src/data/lists/code_extensions.txt
  echo -e "build/config/includes.chroot_after_packages/etc/skel/.deb-gx/install-code-extensions.sh + config-app/src/data/lists/code_extensions.txt created."

}

# :command.function
dgxa_generatechromeex_command() {
  # src/generatechromeex_command.sh
  echo "# this file is located in 'src/generatechromeex_command.sh'"
  echo "# code for 'dgxa generatechromeex' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
  extpage=""

  for i in $(find ~/.config/google-chrome/*/Extensions -name 'manifest.json'); do
      u="https://chrome.google.com/extensions/detail/"
      ue=$(basename $(dirname $(dirname $i)))
      extpage="$extpage$u$ue\n"
  done

  echo -e $extpage >config/chrome_extensions.txt
  echo -e "config/chrome_extensions.txt created."
}

# :command.function
dgxa_buildca_command() {
  # src/buildca_command.sh
  echo "# this file is located in 'src/buildca_command.sh'"
  echo "# code for 'dgxa buildca' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  cd /config-app/
  npm run build
  cd ..

}

# :command.function
dgxa_generateloginscreen_command() {
  # src/generateloginscreen_command.sh
  echo "# this file is located in 'src/generateloginscreen_command.sh'"
  echo "# code for 'dgxa generateloginscreen' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  mkdir -p gresource_src
  files=$(gresource list ./lfs/gnome-shell-theme.gresource)
  wallpaper_name="g4010.png"
  cp ./branding/g4010.png ./gresource_src/g4010.png
  for file in $files; do
      #echo $(basename $file)
      gresource extract lfs/gnome-shell-theme.gresource $file >"./gresource_src/$(basename $file)"
  done

  echo "creating xml .."

  echo -n "" >gresource_src/gnome-shell-theme.gresource.xml

  echo -e '<?xml version="1.0" encoding="UTF-8"?>' >>gresource_src/gnome-shell-theme.gresource.xml
  echo -e "<gresources>" >>gresource_src/gnome-shell-theme.gresource.xml
  echo -e '  <gresource prefix="/org/gnome/shell/theme">' >>gresource_src/gnome-shell-theme.gresource.xml
  echo -e "     <file>${wallpaper_name}</file>" >>gresource_src/gnome-shell-theme.gresource.xml

  for file in $files; do
      name=$(basename $file)
      echo -e "     <file>${name}</file>" >>gresource_src/gnome-shell-theme.gresource.xml

  done

  echo -e "  </gresource>" >>gresource_src/gnome-shell-theme.gresource.xml
  echo -e "</gresources>" >>gresource_src/gnome-shell-theme.gresource.xml

  echo "gnome-shell-theme.gresource.xml cteated."

  #todo: make gresource with dracula theme
  echo "creating gnome-shell.css .."
  sed -i 's/#lockDialogGroup/#lockDialogGroup-bak/' gresource_src/gnome-shell.css
  sed -i 's/1b6acb/bd93f9/' gresource_src/gnome-shell.css

  printf "#lockDialogGroup {\n    background: #44475a url(${wallpaper_name});\n    background-repeat: no-repeat;\n    background-size: cover; }\n" >>gresource_src/gnome-shell.css
  echo "gnome-shell.css created."

  echo "compiling gresource .."
  echo "current folder gresource_src"
  cd gresource_src
  glib-compile-resources gnome-shell-theme.gresource.xml
  cd ..
  echo "gresource compiled."

  cp ./gresource_src/gnome-shell-theme.gresource ./build/config/includes.chroot_after_packages/usr/share/gnome-shell/

}

# :command.function
dgxa_generateplymouthsplash_command() {
  # src/generateplymouthsplash_command.sh
  echo "# this file is located in 'src/generateplymouthsplash_command.sh'"
  echo "# code for 'dgxa generateplymouthsplash' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  #to generate plymouth splash screen, for spezific mp4

  show_current_splash() {
      check_root
      DURATION=$1
      if [ $# -ne 1 ]; then
          DURATION=15
      fi
      plymouthd
      plymouth --show-splash
      for ((i = 0; i < $DURATION; i++)); do
          plymouth --update=duration$i
          sleep 1
      done
      plymouth --quit
  }

  mkdir -p $FILE_SYSTEM_CBP_FOLDER/usr/share/plymouth/themes
  #cp -r ./branding/debgx_plymouth $FILE_SYSTEM_CBP_FOLDER/usr/share/plymouth/themes

}

# :command.function
dgxa_build_command() {
  # src/build_command.sh
  echo "# this file is located in 'src/build_command.sh'"
  echo "# code for 'dgxa build' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  check_root

  start=$(date +%s)

  cd build

  sudo lb clean
  lb config
  sudo lb build

  if validate_file_exists "./live-image-amd64.hybrid.iso"; then
      #sudo mv ./build/live-image-amd64.hybrid.iso ./build/deb-gx_000-amd64.hybrid.iso
      echo "Build $(green done). See build/live-image-amd64.hybrid.iso"
      end=$(date +%s)
      runtime=$((end - start))
      echo "Build Process takes $runtime seconds."
  else
      echo "There was an $(red error) building the iso."
  fi

}

# :command.function
dgxa_setcalamares_command() {
  # src/setcalamares_command.sh
  echo "# this file is located in 'src/setcalamares_command.sh'"
  echo "# code for 'dgxa setcalamares' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  mkdir -p $FILE_SYSTEM_CAP_FOLDER/etc/calamares
  cp -r ./branding/calamares/branding $FILE_SYSTEM_CAP_FOLDER/etc/calamares
  cp ./branding/calamares/settings.conf $FILE_SYSTEM_CAP_FOLDER/etc/calamares

  mkdir -p $FILE_SYSTEM_CAP_FOLDER/usr/share/icons/debgx/
  cp ./branding/calamares/calamares_icon.svg $FILE_SYSTEM_CAP_FOLDER/usr/share/icons/debgx/

  mkdir -p $FILE_SYSTEM_CAP_FOLDER/usr/share/applications/
  cp ./branding/calamares/install-debian.desktop $FILE_SYSTEM_CAP_FOLDER/usr/share/applications/install-debian.desktop

  echo "calamres branding installed"

}

# :command.function
dgxa_setlogin_command() {
  # src/setlogin_command.sh
  echo "# this file is located in 'src/setlogin_command.sh'"
  echo "# code for 'dgxa setlogin' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  if validate_file_exists "./branding/gnome-shell-theme.gresource"; then
      mkdir -p $FILE_SYSTEM_CAP_FOLDER/usr/share/gnome-shell/
      cp ./branding/gnome-shell-theme.gresource $FILE_SYSTEM_CAP_FOLDER/usr/share/gnome-shell/
      echo "gnome-shell-theme.gresource copied."
  else
      echo "./branding/gnome-shell-theme.gresource not found."
      echo "please create an gresource file (e.g with this script) and copy it to ./branding/."
      exit
  fi

}

# :command.function
dgxa_setplymouth_command() {
  # src/setplymouth_command.sh
  echo "# this file is located in 'src/setplymouth_command.sh'"
  echo "# code for 'dgxa setplymouth' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  if validate_dir_exists "./branding/debgx_plymouth/"; then
      mkdir -p $FILE_SYSTEM_CBP_FOLDER/usr/share/plymouth/themes
      cp -r ./branding/debgx_plymouth $FILE_SYSTEM_CBP_FOLDER/usr/share/plymouth/themes
      echo "debgx_plymouth copied."
  else
      echo "./branding/debgx_plymouth not found."
      echo "please create an debgx_plymouth dir (e.g with this script) and copy it to ./branding/."
      exit
  fi

}

# :command.function
dgxa_setfiles_command() {
  # src/setfiles_command.sh
  echo "# this file is located in 'src/setfiles_command.sh'"
  echo "# code for 'dgxa setfiles' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  mkdir -p $USER_LIVE_HOME_FOLDER/.deb-gx
  cp -r ./branding/apps $USER_LIVE_HOME_FOLDER/.deb-gx/
  cp ./branding/xi72yowde.ttf $USER_LIVE_HOME_FOLDER/.deb-gx/xi72yowde.ttf
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        dgxa_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*)
      ;;

    download | d)
      action="download"
      shift
      dgxa_download_parse_requirements "$@"
      shift $#
      ;;

    installdev | id)
      action="installdev"
      shift
      dgxa_installdev_parse_requirements "$@"
      shift $#
      ;;

    generatecodeex | gce)
      action="generatecodeex"
      shift
      dgxa_generatecodeex_parse_requirements "$@"
      shift $#
      ;;

    generatechromeex | gche)
      action="generatechromeex"
      shift
      dgxa_generatechromeex_parse_requirements "$@"
      shift $#
      ;;

    buildca | bca)
      action="buildca"
      shift
      dgxa_buildca_parse_requirements "$@"
      shift $#
      ;;

    generateloginscreen | gls)
      action="generateloginscreen"
      shift
      dgxa_generateloginscreen_parse_requirements "$@"
      shift $#
      ;;

    generateplymouthsplash | gps)
      action="generateplymouthsplash"
      shift
      dgxa_generateplymouthsplash_parse_requirements "$@"
      shift $#
      ;;

    build | b)
      action="build"
      shift
      dgxa_build_parse_requirements "$@"
      shift $#
      ;;

    setcalamares | sc)
      action="setcalamares"
      shift
      dgxa_setcalamares_parse_requirements "$@"
      shift $#
      ;;

    setlogin | sl)
      action="setlogin"
      shift
      dgxa_setlogin_parse_requirements "$@"
      shift $#
      ;;

    setplymouth | sp)
      action="setplymouth"
      shift
      dgxa_setplymouth_parse_requirements "$@"
      shift $#
      ;;

    setfiles | sf)
      action="setfiles"
      shift
      dgxa_setfiles_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      dgxa_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_download_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_download_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="download"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_installdev_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_installdev_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="installdev"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_generatecodeex_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_generatecodeex_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="generatecodeex"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_generatechromeex_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_generatechromeex_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="generatechromeex"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_buildca_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_buildca_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="buildca"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_generateloginscreen_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_generateloginscreen_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="generateloginscreen"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_generateplymouthsplash_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_generateplymouthsplash_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="generateplymouthsplash"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_setcalamares_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_setcalamares_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setcalamares"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_setlogin_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_setlogin_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setlogin"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_setplymouth_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_setplymouth_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setplymouth"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
dgxa_setfiles_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        dgxa_setfiles_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setfiles"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

  check_current_folder_funktion

  USER_LIVE_HOME_FOLDER="./build/config/includes.chroot_after_packages/etc/skel"
  FILE_SYSTEM_CBP_FOLDER="./build/config/includes.chroot_before_packages"
  FILE_SYSTEM_CAP_FOLDER="./build/config/includes.chroot_after_packages"

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "download")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_download_usage
      else
        dgxa_download_command
      fi
      ;;

    "installdev")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_installdev_usage
      else
        dgxa_installdev_command
      fi
      ;;

    "generatecodeex")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_generatecodeex_usage
      else
        dgxa_generatecodeex_command
      fi
      ;;

    "generatechromeex")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_generatechromeex_usage
      else
        dgxa_generatechromeex_command
      fi
      ;;

    "buildca")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_buildca_usage
      else
        dgxa_buildca_command
      fi
      ;;

    "generateloginscreen")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_generateloginscreen_usage
      else
        dgxa_generateloginscreen_command
      fi
      ;;

    "generateplymouthsplash")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_generateplymouthsplash_usage
      else
        dgxa_generateplymouthsplash_command
      fi
      ;;

    "build")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_build_usage
      else
        dgxa_build_command
      fi
      ;;

    "setcalamares")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_setcalamares_usage
      else
        dgxa_setcalamares_command
      fi
      ;;

    "setlogin")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_setlogin_usage
      else
        dgxa_setlogin_command
      fi
      ;;

    "setplymouth")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_setplymouth_usage
      else
        dgxa_setplymouth_command
      fi
      ;;

    "setfiles")
      if [[ ${args[--help]:-} ]]; then
        long_usage=yes
        dgxa_setfiles_usage
      else
        dgxa_setfiles_command
      fi
      ;;

    "root")
      root_command
      ;;

  esac
}

initialize
run "$@"
